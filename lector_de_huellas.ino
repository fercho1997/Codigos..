#include <Adafruit_Fingerprint.h>
#include <SoftwareSerial.h>
#include <Adafruit_GFX.h>  // Include core graphics library for the display
#include <Adafruit_SSD1306.h>  // Include Adafruit_SSD1306 library to drive the display
#include <SPI.h>
#include <Wire.h>
Adafruit_SSD1306 display;
#include <Servo.h>
Servo controlador; 

int getFingerprintIDez();
int verde = 6;
int rojo=7;
int bot_escaneo = 5; 
int bot_cerrar =4;
int bot_abrir =3;
int contador=0 ;

bool reconocimiento =false;
bool inicio = false;

int vall=0;
int valll=0;
int val = 0; //val se emplea para almacenar el estado del boton
int state = 0; // 0 LED apagado, mientras que 1 encendido


static const uint8_t icon [] PROGMEM = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x0f, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x07, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const uint8_t ico [] PROGMEM = {
  0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xcf, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x03, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x1f, 0xb0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0b, 0x70, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xdf, 0xb0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0b, 0x60, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xcf, 0xae, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3d, 0x38, 0xd6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x6f, 0x4f, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x56, 0xd9, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0xed, 0xb6, 0xad, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xab, 0x5d, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd6, 0xbb, 0x6b, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x57, 0xb6, 0xd7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x69, 0xb7, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x6b, 0xd3, 0x77, 0x80, 0x00, 0x00, 0x00, 0x00, 0xe2, 0xf6, 0xd9, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0xea, 0xa9, 0xaf, 0x80, 0x00, 0x00, 0x00, 0x00, 0xea, 0xaa, 0x31, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0xfa, 0xa8, 0xdf, 0x80, 0x00, 0x00, 0x00, 0x00, 0xea, 0xaf, 0x60, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xea, 0xa7, 0x97, 0x80, 0x00, 0x00, 0x00, 0x00, 0x4a, 0xd3, 0xe0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xfd, 0x6d, 0xbf, 0x80, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xb6, 0x80, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xde, 0xdb, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x6d, 0x40, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x6d, 0xb7, 0xed, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xde, 0xad, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x76, 0x6a, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xae, 0xad, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3b, 0x5e, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xd5, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x1d, 0xad, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5a, 0xd0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x04, 0xb6, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3d, 0xa0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80
};
SoftwareSerial mySerial(1,2);

Adafruit_Fingerprint finger = Adafruit_Fingerprint(&mySerial);




void setup()  
{
  Serial.begin(9600);
  controlador.attach(9 );   // put your setup code here, to run once:

  pinMode(6,OUTPUT);
  pinMode(7,OUTPUT);
  pinMode(5,INPUT);
  pinMode(4,INPUT);
  pinMode(3,INPUT);
  while (!Serial);  // For Yun/Leo/Micro/Zero/...
  delay(100);
  Serial.println("Prueba de seguridad");
  
  delay(100);  // This delay is needed to let the display to initialize
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // Initialize display with the I2C address of 0x3C
  display.clearDisplay();  // Clear the buffer
  display.setTextColor(WHITE);  // Set color of the text
  display.setRotation(0);  // Set orientation. Goes from 0, 1, 2 or 3
  display.setTextWrap(false);  // By default, long lines of text are set to automatically “wrap” back to the leftmost column.
                               // To override this behavior (so text will run off the right side of the display - useful for
                               // scrolling marquee effects), use setTextWrap(false). The normal wrapping behavior is restored
  display.dim(0); 
  
  // set the data rate for the sensor serial port
  finger.begin(57600);
  delay(5);
  if (finger.verifyPassword()) {
    Serial.println("Sensor de huellas digitales encontrado!");
    Serial.println("esperando intrucciones ");
    
  display.setTextSize(0); 
  display.setCursor(5, 3);  // (x,y)
  display.println("sensor de Huellas");
   display.setCursor(5, 15);  // (x,y)
  display.println("Digitales Encontrado");// Text or value to print
 display.display();  // Print everything we set previously
     delay(5000);
      display.clearDisplay();  // Clear the display so we can refresh
 delay(1000);
  display.setTextSize(0); 
  display.setCursor(0, 5);  // (x,y)
  display.println(F("Bienvenido :)"));  // Text or value to print
   display.setCursor(0, 15);  // (x,y)
  display.println(F("Esperando Intruccion")); 
 display.display();  // Print everything we set previously
     delay(5000);
  
  } else {
    Serial.println("No encontré el sensor de huellas digitales :(");

 while (1) { delay(1);}
  }


    
  }
  

 
void loop()    
  
{
if (inicio==true)
{
           display.clearDisplay();  // Clear the display so we can refresh
 delay(1000);
  display.setTextSize(0); 
  display.setCursor(0, 5);  // (x,y)
  display.println(F("Bienvenido :)"));  // Text or value to print
   display.setCursor(0, 15);  // (x,y)
  display.println(F("Esperando Intruccion")); 
 display.display();  // Print everything we set previously
     delay(5000);
inicio=false;
}
  
  val=digitalRead(3);
if  ((val == HIGH)){
      Serial.println("pulsador de puerta abierta");
      digitalWrite(6, HIGH);    // Enciende
        controlador.write(90);
  delay(2000);
 display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.setCursor(10, 10);  // (x,y)
  display.println(F("Puerta abierta"));  // Text or value to print
 display.display();  // Print everything we set previously
     delay(5000);
       digitalWrite(6, LOW);
       // Enciende
   inicio=true;
      }
      
   
  vall=digitalRead(4);
  if  ((vall == HIGH))
   {
      Serial.println("pulsador de puerta cerrada");

  digitalWrite(7, HIGH);    // Enciende
        controlador.write(0);
  delay(2000);
 display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.setCursor(10, 10);  // (x,y)
  display.println(F("Puerta cerrada"));  // Text or value to print
 display.display();  // Print everything we set previously
     delay(5000);
       digitalWrite(7, LOW); 
         inicio=true; 
    
   }

 
  valll=digitalRead(5);
  if  ((valll == HIGH)&&contador<=600)
  {contador=contador+1;
    display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.setCursor(20, 10);  // (x,y)
  display.println(F(" Coloca el Dedo"));  // Text or value to print
 display.display();  // Print everything we set previously
     delay(5000);
     reconocimiento= true;
      }

    while(reconocimiento)
    {
       
       getFingerprintID();
   delay(50);   //don't ned to run this at full speed.
 
         getFingerprintID();
   delay(50);   //don't ned to run this at full speed.

  getFingerprintIDez();
  delay(50);   //don't ned to run this at full speed.
   display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.setCursor(20, 10);  // (x,y)
  display.println("Fin del Escaneo");  // Text or value to print
 display.display();  // Print everything we set previously
     delay(5000);
  Serial.println("Fin del Escaneo ");
  
   reconocimiento=false;
   inicio=true;
    

}

}


uint8_t getFingerprintID() {
  uint8_t p = finger.getImage();
  switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Imagen tomada");
      break;
    case FINGERPRINT_NOFINGER:
      Serial.println("No se detecta  ningún dedo");
      return p;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Error de comunicación");
    
      return p;
    case FINGERPRINT_IMAGEFAIL:
      Serial.println("Error de imagen");
   
      return p;
    default:
      Serial.println("Error desconocido");

      return p;
  }

  // OK success!

  p = finger.image2Tz();
  switch (p) {
    case FINGERPRINT_OK:
      Serial.println("Imagen convertida");
      break;
    case FINGERPRINT_IMAGEMESS:
      Serial.println("Imagen demasiado desordenada");
      return p;
    case FINGERPRINT_PACKETRECIEVEERR:
      Serial.println("Error de comunicación");
      return p;
    case FINGERPRINT_FEATUREFAIL:
      Serial.println("No se encontraron características de huellas digitales");
      return p;
    case FINGERPRINT_INVALIDIMAGE:
      Serial.println("No se encontraron características de huellas digitales");
      return p;
    default:
      Serial.println("Error desconocido");
      return p;
  }
  
  // OK converted!
  p = finger.fingerFastSearch();
  if (p == FINGERPRINT_OK) {
    Serial.println("Encontró una coincidencia de impresión!");
    digitalWrite(6, HIGH); 
 controlador.write(90);
  
     display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.drawBitmap(80,0,icon,60,120,WHITE);
 
  display.drawBitmap(10,0,ico,60,60,WHITE);
  delay(3000);
  display.display();  // Print everything we set previously
  delay(3000);
  
            
    display.clearDisplay();  // Clear the display so we can refresh
display.setTextSize(0); 
  display.setCursor(15, 10);  // (x,y)
  display.println("Huella Incontrada ");  // Text or value to print
  display.setCursor(47, 20);  // (x,y)
  display.println(" N");
    display.setCursor(67, 20);  // (x,y)
  display.println(finger.fingerID); 
 display.display();  // Print everything we set previously
     delay(5000);

            
       digitalWrite(6, LOW); 
 
  } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("Error de comunicación");
    return p;
  } else if (p == FINGERPRINT_NOTFOUND) {
    Serial.println("No encontré una coincidencia");
digitalWrite(7, HIGH); 
display.clearDisplay();  // Clear the display so we can refresh

  display.setTextSize(0); 
  display.setCursor(8, 3);  // (x,y)
  display.println(F(" Retirese Intruso "));  // Text or value to print
    display.setCursor(15,15);  // (x,y)
    
  display.setTextSize(2);
  display.println(F("(0.0).!. "));
 display.display();  // Print everything we set previously
     delay(5000);
            delay(2000);
       digitalWrite(7, LOW);
    return p;
  } else {
    Serial.println("Error desconocido");
    return p;
  }   
  
  // huella incontrada!
  Serial.print("Encontrado ID #"); Serial.print(finger.fingerID); 
 Serial.print("con la confianza de "); Serial.println(finger.confidence); 

  return finger.fingerID;
}


// returns -1 if failed, otherwise returns ID #

int getFingerprintIDez() {
  uint8_t p = finger.getImage();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.image2Tz();
  if (p != FINGERPRINT_OK)  return -1;

  p = finger.fingerFastSearch();
  if (p != FINGERPRINT_OK)  return -1;
  
  // found a match!
/// aqui se comprueva la guella 
  
  Serial.print("Encontrado ID #"); Serial.print(finger.fingerID); 
  
  Serial.print(" con la confianza de "); Serial.println(finger.confidence);
  return finger.fingerID; 
{
 getFingerprintIDez();
  delay(50);            //don't ned to run this at full speed.

       finger.fingerID = -1;
     }
 }
